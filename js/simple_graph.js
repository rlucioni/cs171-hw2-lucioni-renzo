// Generated by CoffeeScript 1.7.1
var accessToken, allBranchNames, branch, branchColor, branchLayout, branchName, branches, branchesUrl, candidateNode, canvasHeight, canvasWidth, commit, commits, commitsUrl, contributors, fill, focusNode, force, forceLayout, getData, graph, graphUpdate, i, j, link, metadata, name, node, parent, parseLinkHeader, rootUrl, rootUser, sha, svg, tick, yScale, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

parseLinkHeader = function(header) {
  var links, rel, segments, url, value, values, _i, _len;
  if (header === null) {
    return {};
  }
  values = header.split(',');
  links = {};
  for (_i = 0, _len = values.length; _i < _len; _i++) {
    value = values[_i];
    segments = value.split(';');
    url = segments[0].replace(/<(.*)>/, '$1').trim();
    rel = segments[1].replace(/rel="(.*)"/, '$1').trim();
    links[rel] = url;
  }
  return links;
};

getData = function(url) {
  var data, linkHeader, links, request;
  request = new XMLHttpRequest();
  request.open('GET', url, false);
  request.send();
  if (request.status === 200) {
    data = JSON.parse(request.responseText);
  } else {
    throw new Error("" + request.status + " " + request.statusText);
  }
  linkHeader = request.getResponseHeader("Link");
  links = parseLinkHeader(linkHeader);
  if ("next" in links) {
    data = data.concat(getData(links["next"]));
  }
  return data;
};

accessToken = "5e04d069456442ee6b66b2b87d2a28f215789511";

rootUrl = "https://api.github.com/repos/jsocol/django-waffle/";

rootUser = "jsocol";

contributors = {};

contributors[rootUser] = {};

branchesUrl = "" + rootUrl + "branches?access_token=" + accessToken;

branches = getData(branchesUrl);

for (_i = 0, _len = branches.length; _i < _len; _i++) {
  branch = branches[_i];
  commitsUrl = "" + rootUrl + "commits?sha=" + branch.name + "&per_page=100&access_token=" + accessToken;
  contributors[rootUser][branch.name] = getData(commitsUrl);
}

canvasWidth = 1000;

canvasHeight = 700;

svg = d3.select("body").append("svg").attr("width", canvasWidth).attr("height", canvasHeight);

allBranchNames = [];

for (name in contributors) {
  branches = contributors[name];
  for (branchName in branches) {
    if (__indexOf.call(allBranchNames, branchName) < 0) {
      allBranchNames.push(branchName);
    }
  }
}

fill = d3.scale.ordinal().domain(allBranchNames).range(colorbrewer.Set3[12]);

yScale = d3.scale.ordinal().domain(allBranchNames).rangeRoundBands([0, canvasHeight], 20);

graph = {
  nodes: [],
  links: []
};

for (name in contributors) {
  branches = contributors[name];
  for (branch in branches) {
    commits = branches[branch];
    for (_j = 0, _len1 = commits.length; _j < _len1; _j++) {
      commit = commits[_j];
      metadata = {
        author: commit.commit.author.name,
        message: commit.commit.message,
        branch: branch,
        sha: commit.sha,
        htmlUrl: commit.html_url,
        parentShas: (function() {
          var _ref, _results;
          _ref = commit.parents;
          _results = [];
          for (parent in _ref) {
            metadata = _ref[parent];
            _results.push(metadata.sha);
          }
          return _results;
        })()
      };
      graph.nodes.push(metadata);
    }
  }
}

_ref = d3.range(graph.nodes.length);
for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
  i = _ref[_k];
  focusNode = graph.nodes[i];
  _ref1 = focusNode.parentShas;
  for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
    sha = _ref1[_l];
    _ref2 = d3.range(graph.nodes.length);
    for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
      j = _ref2[_m];
      candidateNode = graph.nodes[j];
      if (sha === candidateNode.sha && focusNode.sha !== candidateNode.sha) {
        graph.links.push({
          source: j,
          target: i
        });
      }
    }
  }
}

console.log("nodes: " + graph.nodes.length + ", links: " + graph.links.length);

tick = function(d) {
  return graphUpdate(0);
};

forceLayout = function() {
  return force.nodes(graph.nodes).links(graph.links).start();
};

branchLayout = function() {
  force.stop();
  graph.nodes.forEach(function(d, i) {
    return d.y = yScale(d.branch);
  });
  return graphUpdate(500);
};

branchColor = function() {
  return d3.selectAll("circle").transition().duration(500).style("fill", function(d) {
    return fill(d.branch);
  });
};

graphUpdate = function(delay) {
  link.transition().duration(delay).attr("x1", function(d) {
    return d.target.x;
  }).attr("y1", function(d) {
    return d.target.y;
  }).attr("x2", function(d) {
    return d.source.x;
  }).attr("y2", function(d) {
    return d.source.y;
  });
  return node.transition().duration(delay).attr("transform", function(d) {
    return "translate(" + d.x + ", " + d.y + ")";
  });
};

force = d3.layout.force().size([canvasWidth, canvasHeight]).charge(-30).linkDistance(10).on("tick", tick).on("start", function(d) {}).on("end", function(d) {});

d3.select("input[value='forceLayout']").on("click", forceLayout);

d3.select("input[value='branchLayout']").on("click", branchLayout);

d3.select("input[value='noColor']").on("click", function() {
  return d3.selectAll("circle").transition().duration(500).style("fill", "#66CC66");
});

d3.select("input[value='branchColor']").on("click", branchColor);

link = svg.selectAll(".link").data(graph.links).enter().append("line").attr("class", "link");

node = svg.selectAll(".node").data(graph.nodes).enter().append("g").attr("class", "node");

node.append("circle").attr("r", 5).attr("stroke", "gray");

forceLayout();
